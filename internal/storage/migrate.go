package storage
package storage

import (
	"context"
	"database/sql"
	"fmt"
	"io/fs"












































































































































}	return strings.Join(kept, "\n")	}		kept = append(kept, line)		}			continue		if strings.HasPrefix(trimmed, "--") {		trimmed := strings.TrimSpace(line)	for _, line := range lines {	kept := make([]string, 0, len(lines))	lines := strings.Split(sqlText, "\n")func stripLineComments(sqlText string) string {}	return nil	}		return fmt.Errorf("record migration %s: %w", id, err)	if err != nil {	_, err := m.db.ExecContext(ctx, `INSERT INTO schema_migrations (id, applied_at) VALUES ($1, $2)`, id, time.Now().UTC())func (m *Migrator) recordApplied(ctx context.Context, id string) error {}	return nil	}		return fmt.Errorf("commit migration %s: %w", id, err)	if err := tx.Commit(); err != nil {	}		return fmt.Errorf("record migration %s: %w", id, err)		_ = tx.Rollback()	if _, err := tx.ExecContext(ctx, `INSERT INTO schema_migrations (id, applied_at) VALUES ($1, $2)`, id, time.Now().UTC()); err != nil {	}		return fmt.Errorf("exec migration %s: %w", id, err)		_ = tx.Rollback()	if _, err := tx.ExecContext(ctx, sqlText); err != nil {	}		return fmt.Errorf("begin migration %s: %w", id, err)	if err != nil {	tx, err := m.db.BeginTx(ctx, nil)func (m *Migrator) applyOne(ctx context.Context, id, sqlText string) error {}	return applied, nil	}		return nil, fmt.Errorf("iterate schema_migrations: %w", err)	if err := rows.Err(); err != nil {	}		applied[id] = true		}			return nil, fmt.Errorf("scan schema_migrations: %w", err)		if err := rows.Scan(&id); err != nil {		var id string	for rows.Next() {	applied := make(map[string]bool)	defer rows.Close()	}		return nil, fmt.Errorf("list schema_migrations: %w", err)	if err != nil {	rows, err := m.db.QueryContext(ctx, `SELECT id FROM schema_migrations`)func (m *Migrator) appliedMigrations(ctx context.Context) (map[string]bool, error) {}	return nil	}		return fmt.Errorf("create schema_migrations: %w", err)	if err != nil {	)`)		applied_at TIMESTAMPTZ NOT NULL		id TEXT PRIMARY KEY,	_, err := m.db.ExecContext(ctx, `CREATE TABLE IF NOT EXISTS schema_migrations (func (m *Migrator) ensureTable(ctx context.Context) error {}	return nil	}		}			return err		if err := m.applyOne(ctx, id, sqlText); err != nil {		}			continue			}				return err			if err := m.recordApplied(ctx, id); err != nil {		if strings.TrimSpace(sqlText) == "" {		sqlText := stripLineComments(string(content))		}			return fmt.Errorf("read migration %s: %w", file, err)		if err != nil {		content, err := fs.ReadFile(m.fs, file)		}			continue		if applied[id] {		id := filepath.Base(file)	for _, file := range files {	}		return err	if err != nil {	applied, err := m.appliedMigrations(ctx)	sort.Strings(files)	}		return nil	if len(files) == 0 {	}		return fmt.Errorf("list migrations: %w", err)	if err != nil {	files, err := fs.Glob(m.fs, "migrations/*.sql")	}		return err	if err := m.ensureTable(ctx); err != nil {	}		return fmt.Errorf("db is required")	if m.db == nil {func (m *Migrator) Up(ctx context.Context) error {}	return &Migrator{db: db, fs: migrations}func NewMigrator(db *sql.DB, migrations fs.FS) *Migrator {}	fs fs.FS	db *sql.DBtype Migrator struct {)	"time"	"strings"	"sort"	"path/filepath"